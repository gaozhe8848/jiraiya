// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: releases.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteRelease = `-- name: DeleteRelease :exec
DELETE FROM releases WHERE version = $1
`

func (q *Queries) DeleteRelease(ctx context.Context, version string) error {
	_, err := q.db.Exec(ctx, deleteRelease, version)
	return err
}

const getAllPlatforms = `-- name: GetAllPlatforms :many
SELECT DISTINCT platform FROM releases WHERE platform != '' ORDER BY platform
`

func (q *Queries) GetAllPlatforms(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllPlatforms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var platform string
		if err := rows.Scan(&platform); err != nil {
			return nil, err
		}
		items = append(items, platform)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllReleasesByPlatform = `-- name: GetAllReleasesByPlatform :many
SELECT version, from_ver, platform, release_date, submitted_by, created_at, updated_at
FROM releases
WHERE platform = $1
`

func (q *Queries) GetAllReleasesByPlatform(ctx context.Context, platform string) ([]Release, error) {
	rows, err := q.db.Query(ctx, getAllReleasesByPlatform, platform)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Release
	for rows.Next() {
		var i Release
		if err := rows.Scan(
			&i.Version,
			&i.FromVer,
			&i.Platform,
			&i.ReleaseDate,
			&i.SubmittedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelease = `-- name: GetRelease :one
SELECT version, from_ver, platform, release_date, submitted_by, created_at, updated_at
FROM releases
WHERE version = $1
`

func (q *Queries) GetRelease(ctx context.Context, version string) (Release, error) {
	row := q.db.QueryRow(ctx, getRelease, version)
	var i Release
	err := row.Scan(
		&i.Version,
		&i.FromVer,
		&i.Platform,
		&i.ReleaseDate,
		&i.SubmittedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVersionsByPlatform = `-- name: GetVersionsByPlatform :many
SELECT version, from_ver, release_date, submitted_by, created_at, updated_at
FROM releases
WHERE platform = $1
ORDER BY release_date DESC
`

type GetVersionsByPlatformRow struct {
	Version     string             `json:"version"`
	FromVer     string             `json:"from_ver"`
	ReleaseDate string             `json:"release_date"`
	SubmittedBy string             `json:"submitted_by"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetVersionsByPlatform(ctx context.Context, platform string) ([]GetVersionsByPlatformRow, error) {
	rows, err := q.db.Query(ctx, getVersionsByPlatform, platform)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVersionsByPlatformRow
	for rows.Next() {
		var i GetVersionsByPlatformRow
		if err := rows.Scan(
			&i.Version,
			&i.FromVer,
			&i.ReleaseDate,
			&i.SubmittedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertRelease = `-- name: UpsertRelease :exec
INSERT INTO releases (version, from_ver, platform, release_date, submitted_by, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, now(), now())
ON CONFLICT (version) DO UPDATE SET
    from_ver = EXCLUDED.from_ver,
    platform = EXCLUDED.platform,
    release_date = EXCLUDED.release_date,
    submitted_by = EXCLUDED.submitted_by,
    updated_at = now()
`

type UpsertReleaseParams struct {
	Version     string `json:"version"`
	FromVer     string `json:"from_ver"`
	Platform    string `json:"platform"`
	ReleaseDate string `json:"release_date"`
	SubmittedBy string `json:"submitted_by"`
}

func (q *Queries) UpsertRelease(ctx context.Context, arg UpsertReleaseParams) error {
	_, err := q.db.Exec(ctx, upsertRelease,
		arg.Version,
		arg.FromVer,
		arg.Platform,
		arg.ReleaseDate,
		arg.SubmittedBy,
	)
	return err
}
