// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jiras.sql

package db

import (
	"context"
)

const getDistinctDomains = `-- name: GetDistinctDomains :many
SELECT DISTINCT j.domain
FROM jiras j
JOIN release_jiras rj ON rj.jira_id = j.id
JOIN releases r ON r.version = rj.release_version
WHERE r.platform = $1 AND j.domain != ''
ORDER BY j.domain
`

func (q *Queries) GetDistinctDomains(ctx context.Context, platform string) ([]string, error) {
	rows, err := q.db.Query(ctx, getDistinctDomains, platform)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var domain string
		if err := rows.Scan(&domain); err != nil {
			return nil, err
		}
		items = append(items, domain)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctImpacts = `-- name: GetDistinctImpacts :many
SELECT DISTINCT j.impact
FROM jiras j
JOIN release_jiras rj ON rj.jira_id = j.id
JOIN releases r ON r.version = rj.release_version
WHERE r.platform = $1 AND j.impact != ''
ORDER BY j.impact
`

func (q *Queries) GetDistinctImpacts(ctx context.Context, platform string) ([]string, error) {
	rows, err := q.db.Query(ctx, getDistinctImpacts, platform)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var impact string
		if err := rows.Scan(&impact); err != nil {
			return nil, err
		}
		items = append(items, impact)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJirasByIDs = `-- name: GetJirasByIDs :many
SELECT id, title, impact, domain, relnotes
FROM jiras
WHERE id = ANY($1::text[])
`

func (q *Queries) GetJirasByIDs(ctx context.Context, ids []string) ([]Jira, error) {
	rows, err := q.db.Query(ctx, getJirasByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Jira
	for rows.Next() {
		var i Jira
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Impact,
			&i.Domain,
			&i.Relnotes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertJira = `-- name: UpsertJira :exec
INSERT INTO jiras (id, title, impact, domain, relnotes)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (id) DO UPDATE SET
    title = EXCLUDED.title,
    impact = EXCLUDED.impact,
    domain = EXCLUDED.domain,
    relnotes = EXCLUDED.relnotes
`

type UpsertJiraParams struct {
	ID       string `json:"id"`
	Title    string `json:"title"`
	Impact   string `json:"impact"`
	Domain   string `json:"domain"`
	Relnotes string `json:"relnotes"`
}

func (q *Queries) UpsertJira(ctx context.Context, arg UpsertJiraParams) error {
	_, err := q.db.Exec(ctx, upsertJira,
		arg.ID,
		arg.Title,
		arg.Impact,
		arg.Domain,
		arg.Relnotes,
	)
	return err
}
